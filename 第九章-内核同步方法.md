##  第九章-内核同步方法

####    原子操作
不可分割的指令

####    内核原子接口
-   原子整数操作：声明为atomic_t的数据才能进行原子操作，编译器不会对atomic_t的值进行访问优化。常用于计数器。
-   原子位操作：原子地对数据的某一位进行操作。原子位操作不需要数据为atomic_t类型，用一般的变量类型也能执行原子位操作。

####    自旋锁 spin lock
-   自旋锁最多只能被一个线程拥有，当获取锁失败的时候就会忙等，等待获取锁。由于线程自旋特别浪费处理器时间，**<font color = 'red'>故自旋锁适用于短期内进行轻量级加锁的场景。</font>**
-   自旋锁不能递归，因为如果可以递归，那么会产生尝试获得同一把自旋锁的情况（AA 死锁）
-   自旋锁可以使用在中断处理程序中。注意在中断处理程序中使用自旋锁要先禁止本地中断，因为如果不禁止本地中断，可能在执行临界区代码时被抢占，抢占的进程可能会尝试申请此自旋锁，这就产生了死锁。
-   内核有提供禁止中断同时申请锁的接口：spin_lock_irqsave 和 spin_lock_irqrestore。

####    读写锁 rw lock
-   可以并发读，但不能并发写。对于写者，在写执行的时候只能有一个写者，且不能有读者；对于读者，在读执行的时候能有多个读者，但不能有写者。
-   读锁和写锁要位于完全分割开的代码分支中，如果不能清晰地分开，那么不要用读写锁，用自旋锁。
-   读写锁照顾读者大于照顾写者，而写者为了获得写锁只能等待，而读者在写者等待的时候还可以获取读锁，那有大量读操作的时候写者会饥饿。

**<font color = 'red'>加锁时间短并且代码不会睡眠，那么自旋锁ok。如果加锁时间长或者代码可能睡眠，那么用信号量。</font>**

####    信号量
-   信号量是一种睡眠锁，如果有任务尝试去获取已经被占用的信号量时，信号量会让这个尝试获取信号量的任务进入等待队列，让这个任务睡眠，释放处理器。待信号量被释放后，等待队列的队头任务被唤醒，获得信号量。由于任务获取信号量失败后就去睡眠，**<font color = 'red'>故信号量适用于锁长时间占用的情况。</font>**
-   如果是短时间睡眠那么直接用自旋锁就行了，因为维护信号量还需要维护等待队列，且唤醒和睡眠操作也需要开销。任务在持有信号量的时候可以去睡眠（反正信号量的设计也是长时间占用锁），且不会死锁，因为别的任务获取不到会去睡眠，等待占用锁的任务被唤醒、执行、释放信号量后才会被唤醒。
-   占用信号量的时候不能占用自旋锁。因为自旋锁内不允许睡眠。
-   信号量有两种，一种是限定同一时间只能有一个任务在临界区执行（互斥信号量），另一种是几个任务可以同时在临界区执行。一般来说用的都是互斥信号量

